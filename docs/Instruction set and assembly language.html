<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- Source: http://www.cs.toronto.edu/~hehner/csc258/comp.html -->
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
		<title>The CSC 258 Computer</title>
	</head>
	
	<body>
		<h1>The CSC 258 Computer</h1>
		
		<ul>
			<li>Memory is word addressable, 4 bytes per word, 24-bit addresses (64 MiB)</li>
			<li>32-bit arithmetic (two's complement integers, IEEE single-precision floating-point)</li>
			<li>Accumulator, 32 bits (AC)</li>
			<li>Condition code, 1 bit (E)</li>
			<li>Input port, 8-bit parallel</li>
			<li>Output port, 8-bit parallel</li>
		</ul>
		
		<h2>Instructions</h2>
		
		<table>
			<thead>
				<th>Mnemonic</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr><td>LDA <var>m</var></td><td>(LoaD Accumulator) Load the contents of memory location <var>m</var> into AC.</td></tr>
				<tr><td>STA <var>m</var></td><td>(STore Accumulator) Store the contents of AC at memory location <var>m</var>.</td></tr>
				<tr><td>ADD <var>m</var></td><td>(ADD) Integer add the contents of memory location <var>m</var> to the contents of AC and put the sum in AC; if overflow, E is 1, otherwise E is 0.</td></tr>
				<tr><td>SUB <var>m</var></td><td>(SUBtract) Integer subtract the contents of memory location <var>m</var> from the contents of AC and put the difference in AC; if overflow, E is 1, otherwise E is 0.</td></tr>
				<tr><td>MUL <var>m</var></td><td>(MULtilpy) Integer multiply the contents of AC by the contents of memory location <var>m</var> and put the product in AC; if overflow, E is 1, otherwise E is 0.</td></tr>
				<tr><td>DIV <var>m</var></td><td>(DIVide) Integer divide the contents of the accumulator by the contents of memory location <var>m</var> and put the quotient in AC; if divisor is 0, E is 1, otherwise E is 0.</td></tr>
				<tr><td>MOD <var>m</var></td><td>(MODulo) Integer divide the contents of the accumulator by the contents of memory location <var>m</var> and put the remainder in AC; if divisor is 0, E is 1, otherwise E is 0.</td></tr>
				<tr><td>FLA <var>m</var></td><td>(FLoating Add) Floating-point add the contents of memory location <var>m</var> to the contents of AC and put the sum in AC; if overflow, E is 1, otherwise E is 0.</td></tr>
				<tr><td>FLS <var>m</var></td><td>(FLoating Subtract) Floating-point subtract the contents of memory location <var>m</var> from the contents of AC and put the difference in AC; if overflow, E is 1, otherwise E is 0.</td></tr>
				<tr><td>FLM <var>m</var></td><td>(FLoating Multiply) Floating-point multiply the contents of AC by the contents of memory location <var>m</var> and put the product in AC; if overflow, E is 1, otherwise E is 0.</td></tr>
				<tr><td>FLD <var>m</var></td><td>(FLoating Divide) Floating-point divide the contents of the accumulator by the contents of memory location <var>m</var> and put the quotient in AC; if divisor is 0 or overflow, E is 1, otherwise E is 0.</td></tr>
				<tr><td>CIF <var>m</var></td><td>(Convert Integer to Float) Load the contents of memory location <var>m</var> into AC and convert from integer to float.</td></tr>
				<tr><td>CFI <var>m</var></td><td>(Convert Float to Integer) Load the contents of memory location <var>m</var> into AC and convert from float to the nearest integer.</td></tr>
				<tr><td>AND <var>m</var></td><td>(AND) AND each bit of AC with the corresponding bit of memory location <var>m</var> and put the result in AC; if the result is all 0s, E is 0, otherwise E is 1.</td></tr>
				<tr><td>IOR <var>m</var></td><td>(Inclusive OR) OR each bit of AC with the corresponding bit of memory location <var>m</var> and put the result in AC; if the result is all 0s, E is 0, otherwise E is 1.</td></tr>
				<tr><td>XOR <var>m</var></td><td>(eXclusive OR) XOR each bit of AC with the corresponding bit of memory location <var>m</var> and put the result in AC; if the result is all 0s, E is 0, otherwise E is 1.</td></tr>
				<tr><td>BUN <var>m</var></td><td>(Branch UNconditional) Branch to memory location <var>m</var>.</td></tr>
				<tr><td>BZE <var>m</var></td><td>(Branch on Zero E) If E is 0, branch to memory location <var>m</var>.</td></tr>
				<tr><td>BSA <var>m</var></td><td>(Branch and Save Address) Store the address of the next instruction (i.e., following this instruction) at memory location <var>m</var>, and branch to memory location <var>m</var> + 1.</td></tr>
				<tr><td>BIN <var>m</var></td><td>(Branch INdirect) Branch to the memory location whose address is contained in memory location <var>m</var>.</td></tr>
				<tr><td>INP <var>m</var></td><td>(INPut) If the input port has a byte of information ready, put it in the low-order (rightmost) 8 bits of AC and 0s in the high-order 24 bits; otherwise branch to memory location <var>m</var>.</td></tr>
				<tr><td>OUT <var>m</var></td><td>(OUTput) If the output port is ready to receive a byte of information, send the low-order 8 bits of AC; otherwise branch to memory location <var>m</var>.</td></tr>
			</tbody>
		</table>
		
		<h2>Data</h2>
		
		<table>
			<thead>
				<th>Type</th>
				<th>Description</th>
			</thead>
			<tbody>
				<tr><td>I 123</td><td>Data word, integer format</td></tr>
				<tr><td>F -1.2</td><td>Data word, floating-point format</td></tr>
				<tr><td>C 'abc'</td><td>Data word, character format, in reverse order padded on left with 0s to 4 characters</td></tr>
				<tr><td>B 1010</td><td>Data word, binary format, padded on left with 0s to 32 bits</td></tr>
				<tr><td>H 5BF2</td><td>Data word, hexadecimal integer format, padded on left with 0s to 8 digits</td></tr>
				<tr><td>A there</td><td>Data word, address (identifier or number)</td></tr>
				<tr><td>W 123</td><td>The specified number of data words, with no initialization</td></tr>
			</tbody>
		</table>
		
		<p>An assembly language program consists of a sequence of lines; each line says what's in one word of memory (except for the W data format). A line begins with zero or more labels; each label is an identifier followed by a colon. After that, the line is either in instruction format or in data format. Instruction format is an op-code followed by an address. The op-code is three letters, and the address is either a number or an identifier. Data format is one of I (for two's complement integer), F (for IEEE floating point number), C (for ASCII character), B (for binary), H (for hexadecimal), A (for address), or W (for word) followed by the indicated data. The W format reserves the indicated number of words of memory. The remainder of any line can be used for comments. W 0 can be used just for a label, or just for a comment. Here is a sequence of example lines (this is not a sensible program).</p>
		
		<pre> main: LDA x
       ADD c3
       STA y
       BUN there
    x: I   0
    y: F   -1.2e3
   c3: I   3
there: BUN opsys</pre>
		
		<p>Execution starts at label <code>main</code>. Execution of your program ends with a branch to the operating system at address <code>opsys</code>. All identifiers used as addresses, except <code>opsys</code>, should be defined as labels. An identifier cannot be defined more than once as a label.</p>
	
	</body>
</html>
